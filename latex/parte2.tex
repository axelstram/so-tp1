\subsection{Introducción}
En esta sección se extiende el simulador con un nuevo algoritmo de scheduling, \textit{Round Robin}, y se lo testea con 
diversos lotes de tareas.

\subsection{Ejercicio 3}
El objetivo de este ejercicio es implementar la política de scheduling \textit{Round Robin}. La función más importante es \texttt{tick(cpu, motivo)}, cuya implementación se 
describe a continuación: si el motivo es \textbf{TICK} o \textbf{BLOCK}, se aumenta el contador de ticks del core correspondiente. Si este contador supera el quantum del core, se 
vuelve a poner el contador en $0$, se encola la tarea actual y comienza a ejecutarse la siguiente tarea en la cola; caso contrario, se sigue ejecutando la tarea actual.

Si el motivo es \textbf{EXIT}, sencillamente se devuelve la proxima tarea en la cola, sin encolar nuevamente la tarea actual. En caso de no haber más tareas, se ejecuta \textbf{IDLE\_TASK}.

Para más detalles, consultar la implementación en el archivo \textit{sched\_rr.cpp}.

\subsection{Ejercicio 4}
En esta parte nos vamos a focalizar en la utilización de la política de scheduling implementada anteriormente para mostrar cómo se comporta la misma con diversos quantums y cantidad de cores. La intención es mostrar cuan eficiente o ineficiente puede ser una misma política tan solo con variar el quantum y mostrar que la elección del mismo es muy importante.
Para tal motivo vamos a usar el lote \textit{lote_ej4.tsk} que contiene 4 tareas intensas en CPU y 3 interactivas. Las de CPU llegan en el momento $0$, luego una interactiva en el momento $2$ y otras dos mas en el momento $8$.

Como primer política vamos a tomar un RR con quantum 3, y costo de cambio de contexto de 0, con sólo un core.

\includegraphics[width=1\textwidth]{./Graficos/ej4_1.png}
\begin{center}
 \textit{Cores = 1, Quantum = 3, CS = 0}.
\end{center}

Como podemos apreciar, se ejecutan en una primera pasada las tareas de cpu (de la 0 a la 3 inclusive) que no son interrumpidas. 

\input{ej5.tex}