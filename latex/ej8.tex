\subsection{Ejercicio 8}
En la presente sección vamos a trabajar sobre un algoritmo de scheduling de tipo Round Robin pero que no permite la migración de procesos entre
núcleos. Para tal motivo se utiliza una cola de \texttt{READY} para cada core, donde una vez que el proceso llega se moviliza sólo por esa cola.

Cuando el proceso es bloqueado debemos tener una manera de saber a qué CPU pertenecía dicho proceso, y para tal fin cada core también tiene una
cola de \texttt{BLOQUED}. Entonces, cuando un proceso es desbloqueado simplemente se lo busca en alguna de las listas \texttt{BLOQUED} de los cores,
y una vez que se lo encuentra se lo agrega a la cola \texttt{READY} correspondiente al core que tenía esa tarea bloqueada. Esto hace que cada CPU
tenga un esquema de Round Robin de un sólo core independiente del resto.

A continuación mostramos un gráfico correspondiente al procesamiento del lote de tareas \textit{lote5.tsk} para este nuevo scheduler.
Las tareas se encolan acorde a su momento de llegada y a la carga de los demás cores. Las tres primeras se cargan una en cada core, la cuarta
se carga en el primer core ya que todos estan igualmente cargados. Luego todas siguen ejecutándose en sus respectivos cores sin cambios de
lugar como es esperado.


\includegraphics[width=1\textwidth]{./Graficos/ej8_1.png}
\begin{center}
 \textit{Cores = 3, Qantum = 3 cada core, CS = 1}.
\end{center}

Ahora, con el objetivo de comparar con la política de scheduling de una sola cola, vamos a correr el mismo lote para ver cómo se comporta.
A continuación se encuentra el gráfico con la distribución de las tareas.

\includegraphics[width=1\textwidth]{./Graficos/ej8_2.png}
\begin{center}
 \textit{Cores = 3, Qantum = 3 cada core, CS = 1, CI = 2}.
\end{center}

Un detalle que vale la pena mencionar es que las tareas desde que iniciar hasta que finalizar estan asociadas a un solo core en el caso del
grafico uno. No ocurre asi en el gráfico 2, en donde porciones de la tarea van cambiando de core, como se ve en el segundo gráfico.

Para este lote de tareas en particular podemos apreciar que \texttt{SchedRR2} y \texttt{SchedRR} finalizan la ejecución de todas las tareas
en un tiempo similar. Pero en el primer caso dos de las tareas finalizan rápido, algo que no sucede en el segundo caso, sin contar que en
\texttt{SchedRR2} no hay costos por cambio de core, que sí presenta \texttt{SchedRR}.

Por otro lado, si bien es cierto que \texttt{SchedRR2} termina dos de las tres tareas más rápido, también es cierto que esos cores quedan
inactivos el resto del tiempo (para este lote) algo que no es deseable. Esta comparativa nos brinda un indicio de que si bien \texttt{SchedRR2}
parece más eficiente, para algunos escenarios puede presentar desventajas con respecto a \texttt{SchedRR}, y dicho escenario es cuando
un core se queda con muchas tareas pendientes y los demás no poseen ninguna. Para estos casos se podría implementar alguna política de balance
de carga, es decir, si un core tiene muchas tareas y los demás ninguna, se podrían mover algunas tareas del core más ocupado para los de menos
carga. En este caso estaríamos pagando la penalización del cambio de core (por el traslado de colas), pero es preferible eso antes que algún
core quede inactivo.

A continuación vamos a correr nuevamente los dos schedulers con el lote de tareas \texttt{lote6.tsk} que resultará en tareas pesadas para
el core 0, y tareas mas livianas para el resto. El primer core tendrá un quantum mas grande que los otros. La idea es mostrar un escenario
en donde puedo aprovechar cierta característica de los cores.

La idea detrás del diseño de este lote es construirlo para que el core 0 tome las tareas mas pesadas (en cuanto a CPU) y el resto las más
livianas. Además se configura la corrida del scheduler con tres cores, de los cuales el primero tiene un quantum mas alto que los demás.
Así queda el procesamiento del \texttt{lote6.tsk} con \texttt{SchedRR2}:

\includegraphics[width=1\textwidth]{./Graficos/ej8_3.png}
\begin{center}
 \textit{Cores = 3, Qantum = 3 cada core, CS = 1}.
\end{center}

Y con \texttt{SchedRR} el procesamiento de dicho lote queda de la siguiente forma:

\includegraphics[width=1\textwidth]{./Graficos/ej8_4.png}
\begin{center}
 \textit{Cores = 3, Qantum = 3 cada core, CS = 1, CI = 2}.
\end{center}

Vemos que para este lote, \texttt{SchedRR2} tiene mejor performance. Las tareas son finalizadas más rápido, y todo el lote es procesado
más rápido que en \texttt{SchedRR}. Aún así en \texttt{SchedRR2} tenemos bastante tiempo de procesamiento en donde un procesador u otro permanece ocioso.
Eso ocurre también en \texttt{SchedRR} pero es menor la cantidad de tiempo que los cores permanecen ociosos, aunque el desempeño final es peor.

Para ver esto más claro, a continuación mostramos los graficos de las actividades de los cores a lo largo del tiempo para el \texttt{lote6.tsk}
usando exactamente los mismos parámetros. El primero es usando el scheduler RR2:


\includegraphics[width=1\textwidth]{./Graficos/ej8_out_cores_timeline.png}
\begin{center}
 \textit{Cores = 3, Qantum = 3 cada core, CS = 1}.
\end{center}

El siguientes es con el scheduler RR:

\includegraphics[width=1\textwidth]{./Graficos/ej8_out_cores_timeline_2.png}
\begin{center}
 \textit{Cores = 3, Qantum = 3 cada core, CS = 1, CI = 2}.
\end{center}

En este segundo gráfico podemos ver mejor cómo es que el tiempo de cambio de core afecta al tiempo total de procesamiento del lote. El costo de cambio de core
es nulo en RR2 debido a que las tareas se asignan a un core fijo hasta que finalizan.
Algunas conclusiones que podemos sacar con esta corrida de lotes y las de puntos anteriores de RR son:

\begin{itemize}
	\item El rendimiento de ambos schedulers depende mucho del contexto, es decir, de cómo vienen dadas las tareas, sus tipos, duraciones, orden, etc.
	Hay ciertos lotes que favorecen el uso de RR y hay otros que favorecen el uso de RR2.
	\item A nivel implementativo, RR es más fácil que RR2.
	\item Una de las ventajas de RR2 es que no se paga el costo de cambio de cores, ya que cada tarea posee un único core en el que se ejecuta.
	\item Una desventaja de RR2 es que puede, en algunas situaciones, dejar cores ociosos. RR también lo hace pero en mucha menor medida. En el caso de
	RR depende más que nada de la cantidad de tareas que quedan en relación al número de cores. En caso de RR2, pueden quedar muchas tareas asignadas a un solo core
	y ninguna al resto.
	\item Si hubiese a priori una política de balance de carga de los cores para RR2, estos estarían menos tiempo ociosos y mejoraría la performance del scheduler.
\end{itemize}